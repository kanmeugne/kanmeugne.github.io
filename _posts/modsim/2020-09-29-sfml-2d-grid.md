---
title:  "Drawing a 2D Grid with SFML"
teaser: "Building a 2D Grid is a very common exercice in computer vision, fluid simulation, navigation flow simulation, etc. In this post, I am sharing a C++ code for 2D Grid manipulation. The provided code can be easily used for modeling or simulation purposes."
tags:
    - sfml
    - cmake
    - c++
    - simulation
    - modeling
categories:
    - modeling & simulation
---

Building a 2D Grid is a simple but very critical task. I had to do many time since I started to study modeling and simulation of moving agents (vehicle, pedestrians, robots, etc.). In fact, in those cases, a 2D Grid is the simplest you can get if you are looking for a navigable space model for your path calculation and collision avoidance algorithms. In this post, I am sharing a simple architecture --- with its C++ implementation --- that you can use to integrate a simple and customizable 2D Grid in a simulation app.

## The architecture

Keep in mind that the goal is not only to draw a grid, but to hold an object that we can easily manipulate in simulation. Therefore, for this exercice, I am going to assume that I am building a simulator. Below, the general description of the object-oriented architecture (see **Fig.1**) I am going to use.

{% plantuml %}
@startuml
title: <size:10> Fig. 1. Architecture of our 2D Grid App </size>
package geometry <<Frame>>
{
    class Point {
        + int x
        + int y
    }
    class Segment {
        + Point init
        + Point end
    }
    interface ISegmentFunctor {
        + virtual void operator(const Segment&)
    }
}
abstract class AbstractViewer {
    + virtual void iActivate()
    + virtual void iDeactivate()
    + virtual void iIsActive() const
    + virtual void iSetApp(App*)
    + virtual void iDisplay();
    # {abstract} virtual void iDraw()
    # bool _active = false
}
class App {
    + {static} const int DEFAULT_HEIGHT
    + {static} const int DEFAULT_WIDTH
    + {static} const int DEFAULT_RESX
    + {static} const int DEFAULT_RESY
    + void run()
    + void display()
}
class CELL {
    + int id
    + int state
}
class GridViewer extends AbstractViewer {
    - void drawLines(geometry::ISegmentFunctor&)
    + void initialize()
    # void iDraw()
}
interface IGrid {
    + virtual bool iInitialize() const
    + virtual int iGetSizeX() const
    + virtual int iGetSizeY() const
    + virtual int iGetResolutionX() const
    + virtual int iGetResolutionY() const
    + virtual int iGetNumberOfCells() const
    + virtual bool iGetCellPosition(CELL, int&, int&) const
    + virtual bool iGetCellLocation(CELL, int&, int&) const
    + virtual bool iGetCellNumber(int, int, CELL&) const
    + virtual bool iGetContainingCell(int, int, CELL&) const
    + virtual bool iIsWithinCell(int, int, CELL) const
}
class Grid implements IGrid {
    - int resx
    - int resy
    - int sizex
    - int sizey
}
IGrid <. CELL : subtype <
Grid *--> CELL
App o--> IGrid : controls >
App o-- AbstractViewer
Segment *-> Point : has 2 >
ISegmentFunctor .> Segment
GridViewer ..> geometry

hide members
@enduml

{% endplantuml %}

## App

The *App* object is our application (see **Fig.2**). Basically, it is meant to hold a viewer (*AbstractViewer*) --- that contains  instructions to display what we need to see on the screen --- and a reference to a 2D Grid (*IGrid*) that will be used to manipulate the grid data. Note that some default values --- for the grid size and shape --- are stored as static attributes in the *App* object :
- *App::DEFAULT_HEIGHT* is the *default height* of the grid (in terms of number of cells).
- *App::DEFAULT_WIDTH* is the *default width* of the grid (*idem*).
- *App::DEFAULT_RESX* is the *default width* of a cell (in terms of pixels).
- *App::DEAFULT_RESY* is the *default height* of a cell (*idem*).

More, the App object will hold two important methods for the simulation :
- *App::run* : responsible of the simulation logic
- *App::display* : responsible of the appearence (what we see on the screen)

As you can imagine, those methods are clearly just wrappers of low-level graphical engine calls (we will use [SFML][1]).

{% plantuml %}
@startuml
title: <size:10>Fig. 2. App object is attached to a viewer (AbstractViewer) and controls a 2D Grid (IGrid)</size>
class App {
    + {static} const int DEFAULT_HEIGHT
    + {static} const int DEFAULT_WIDTH
    + {static} const int DEFAULT_RESX
    + {static} const int DEFAULT_RESY
    + void run()
    + void display()
}
abstract class AbstractViewer
interface IGrid
App o-- AbstractViewer
App o--> IGrid : controls >
hide IGrid members
hide AbstractViewer members

@enduml
{% endplantuml %}


### *AbstractViewer* and GridViewer

Like its name says, *AbstractViewer* is an abstract class that is meant to be concretized in regards to what we want to show on the screen - we can even imagine 
a composite-pattern's like design for more flexibility. Basically the *AbstractViewer* is attached to an *App* object and, most importantly, holds a protected abstract method called *AbstractViewer::iDraw* that is meant to be concretized in inherited classes. *AbstractViewer::iDraw* is called by the public method *AbstractViewer::iDisplay* (see **Fig.3**).

For the exercice, we will define *GridViewer* as our only viewer, reponsible of displaying the lines of the 2D Grid. The methods defined in *GridViewer* are the following :
- *GridViewer::initialize* : build the set of segments to be displayed
- *GridViewer::drawLine* : call the engine to draw every segment built during the initialization step *GridViewer::initialize*
- *GridViewer::iDraw* : simply call the above methods in the right order.

{% plantuml %}

@startuml
title
<size:10> Fig. 3. GridViewer is a specific viewer (i.e. inherits from AbstractViewer) in charge of drawing the lines (horizontal and vertical) of the grid. It uses the geometry package </size>
end title
class App {
    + {static} const int DEFAULT_HEIGHT
    + {static} const int DEFAULT_WIDTH
    + {static} const int DEFAULT_RESX
    + {static} const int DEFAULT_RESY
    + void run()
    + void display()
}
abstract class AbstractViewer {
    + virtual void iActivate()
    + virtual void iDeactivate()
    + virtual void iIsActive() const
    + virtual void iSetApp(App*)
    + virtual void iDisplay();
    # {abstract} virtual void iDraw()
    # bool _active = false
}
class GridViewer {
    - void drawLines(geometry::ISegmentFunctor&)
    + void initialize()
    # void iDraw()
}
package geometry <<Frame>>{

}
class GridViewer extends AbstractViewer
App o-- AbstractViewer
GridViewer ..> geometry
hide App members
hide GridViewer fields

@enduml

{% endplantuml %}

*GridViewer will be set to *App* in the main function.

### The 2D Grid

The most important features of our 2D grid are defined the interface *IGrid*  (see **Fig.4**).

The main methods are listed as follows :
- *IGrid::iGetSizeX* : returns the width of the grid (in terms of number of cells)
- *IGrid::iGetSizeY* : returns the height of the grid (*idem*)
- *IGrid::iGetResolutionX* : returns the width of the cell (in terms of pixels)
- *IGrid::iGetResolutionY* : returns the height of the cell (*idem*)
- *IGrid::iGetNumberOfCells* : returns the total number of cells
- *IGrid::iGetCellPosition* : returns the X-Y grid-relative position of a cell given its id
- *IGrid::iGetCellLocation*: returns absolute X-Y position of a cell given its id
- *IGrid::iGetCellNumber* : returns the id of a cell given its X-Y grid-relative position
- *IGrid::iGetContainingCell* : returns the containing cell given a random position on the screen
- *IGrid::iIsWithinCell*: returns true if the cell contains the position and false otherwise

{% plantuml %}
@startuml
title: <size:10> Fig. 4. Grid realizes the interface of a 2D grid, defined in IGrid. </size>
class App {
    + {static} const int DEFAULT_HEIGHT
    + {static} const int DEFAULT_WIDTH
    + {static} const int DEFAULT_RESX
    + {static} const int DEFAULT_RESY
    + void run()
    + void display()
}
class CELL {
    + int id
    + int state
}
interface IGrid {
    + virtual bool iInitialize() const
    + virtual int iGetSizeX() const
    + virtual int iGetSizeY() const
    + virtual int iGetResolutionX() const
    + virtual int iGetResolutionY() const
    + virtual int iGetNumberOfCells() const
    + virtual bool iGetCellPosition(CELL, int&, int&) const
    + virtual bool iGetCellLocation(CELL, int&, int&) const
    + virtual bool iGetCellNumber(int, int, CELL&) const
    + virtual bool iGetContainingCell(const int, const int, CELL) const
    + virtual bool iIsWithinCell(const int, const int, CELL) const
}
class Grid implements IGrid {
    - int resx
    - int resy
    - int sizex
    - int sizey
}
IGrid <. CELL : subtype <
Grid *--> CELL
App o--> IGrid : controls >
hide App members
hide IGrid fields
hide CELL methods
hide Grid methods
@enduml
{% endplantuml %}

*IGrid* is realized by the *Grid* object which is composed of grid cells (described as *IGrid::CELL* objects).

### geometry package
Last but not the least, our very modest geometry package which contains (see **Fig.5**) :
- *geometry::Point* : a 2D point definition, actually a pair of integers
- *geometry::Segment* : the definition of a segment - a pair of *geometry::Point*
- *geometry::ISegmentFunctor* : an interface, meant to be realised by functors that applies on *geomtry::Segment*

{% plantuml %}
@startuml
title: <size:10> Fig. 5. GridViewer uses a very light geometry package to structure the grid lines to be displayed. </size>
package geometry <<Frame>>
{
    class Point {
        + int x
        + int y
    }
    class Segment {
        + Point init
        + Point end
    }
    interface ISegmentFunctor {
        + virtual void operator(const Segment&)
    }
}
class GridViewer
Segment *-> Point : has 2 >
ISegmentFunctor .> Segment
GridViewer ..> geometry
hide Point methods
hide Segment methods
hide ISegmentFunctor fields
hide GridViewer members
@enduml
{% endplantuml %}

The *geometry package* are used by viewers --- GridViewer in our example --- for drawing purposes.

## Build and Run

Our 2D Grid app architecture is now complete! The build strategy is exactly the same as what we have presented in a previous post --- we refer the reader to that post for more details. The main file for the demo will look like this (the complete code is forkable from [here][2]) :

{% highlight c++ %}
#include "App.h"
#include "GridViewer.h"
#include "Grid.h"
#include <thread>
#include <SFML/Graphics.hpp>

#ifdef __linux__
#include <X11/Xlib.h>
#endif

int main()
{
#ifdef __linux__
    XInitThreads();
#endif
    // -- sfml windows
    sf::ContextSettings settings;
    settings.antialiasingLevel = 10;
    sf::RenderWindow window(
        sf::VideoMode(
            (App::DEFAULT_WIDTH*App::DEFAULT_RESX),
            (App::DEFAULT_HEIGHT*App::DEFAULT_RESY)
        ),
        "SFML 2D Grid",
        sf::Style::Titlebar | sf::Style::Close,
        settings
    );
    window.clear(sf::Color::White);
    window.setFramerateLimit(120);
    window.setActive(false);
    
    // -- application
    App app;
    app.setWindow(&window);
    
    //-- grid 2D
    Grid g;
    g.setSizeX(App::DEFAULT_WIDTH);
    g.setSizeY(App::DEFAULT_HEIGHT);
    g.setResolutionX(App::DEFAULT_RESX);
    g.setResolutionY(App::DEFAULT_RESY);
    g.iInitialize();
    app.setGrid(&g);
    
    //-- viewer
    GridViewer gviewer;
    app.setViewer(&gviewer);
    gviewer.initialize();
    gviewer.iActivate();
    
    //-- launch application
    std::thread rendering_thread(&App::display, &app);
    app.run();
    rendering_thread.join();
    
    return 0;
}
{% endhighlight %}

The interested reader can fork the complete source code from [here][2] and run the following in a terminal at the project folder root :

{% highlight shell %}
  # on windows
  $ cmake  -G "Visual Studio 15 2017" -S . -B ./build 
  $ cmake  --build ./build --config Debug --target app
  $ ./bin/Debug/app

  # on linux
  $ mkdir build  
  $ cd build
  $ cmake -G "Unix Makefiles" .. -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build ./ --target app
  $ ../bin/Debug/app
{% endhighlight %}

The program should display a window like this :

![screenshot](/images/2d-grid-demo.png)

This is a functional and customizable 2D Grid that we can use in simulation! Enjoy and feel free to send me your feedbacks!


[1]: https://www.sfml-dev.org/
[2]: https://github.com/kanmeugne/sfml2dgrid/releases/tag/sfml-2d-grid